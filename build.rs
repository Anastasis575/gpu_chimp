use std::{
    env, fs,
    io::Write,
    path::{Path, PathBuf},
};

fn main() {
    let shader_dir = PathBuf::from("shaders");
    if !shader_dir.exists() {
        // Not an error; just no generated file
        return;
    }
    println!("found shaders");
    let out_dir = PathBuf::from(env!("OUT_DIR").unwrap());
    let out_file = out_dir.join("shaders.rs");

    println!("Output file=shaders.rs");

    // Collect all shader files (recursively)
    let mut files = Vec::new();
    collect_shader_files(&shader_dir, &mut files).unwrap();

    // Tell Cargo when to rerun
    println!("cargo:rerun-if-changed=shaders");
    for f in &files {
        println!("cargo:rerun-if-changed={}", f.display());
    }
    let mut code = String::new();
    code.push_str("// @generated by build.rs. Do not edit.\n");
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("pub fn shader(path: &str) -> Option<&'static str> {\n");
    code.push_str("    static MAP: once_cell::sync::Lazy<HashMap<&'static str, &'static str>> = once_cell::sync::Lazy::new(|| {\n");
    code.push_str("        let mut m = HashMap::new();\n");
    for (k, v) in entries {
        code.push_str(&format!("        m.insert({:?}, \"{}\");\n", k, v));
    }
    code.push_str("        m\n");
    code.push_str("    });\n");
    code.push_str("    MAP.get(path).copied()\n");
    code.push_str("}\n");

    // Write file
    fs::create_dir_all(&out_dir).unwrap();
    let mut f = fs::File::create(out_file).unwrap();
    f.write_all(code.as_bytes()).unwrap();
}
    println!("Created shaders in {}", out_file.to_str().unwrap())
fn collect_shader_files(dir: &Path, out: &mut Vec<PathBuf>) -> std::io::Result<()> {
    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() {
            collect_shader_files(&path, out)?;
        } else if let Some(ext) = path.extension() {
            if ext == "wgsl" {
                out.push(path);
            }
        }
    }
    Ok(())
}
